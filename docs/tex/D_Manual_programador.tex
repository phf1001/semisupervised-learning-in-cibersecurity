\apendice{Documentación técnica de programación}

\section{Introducción}

\section{Estructura de directorios}

...

\begin{figure}[h]
	\caption[Diagrama: estructura de directorios]{Diagrama que representa la estructura física de directorios en el repositorio.}
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/diagrams/repo-structure}
	\label{d:diag-repo-structure}
\end{figure}

\section{Manual del programador}

\section{Compilación, instalación y ejecución del proyecto}

\subsection{Entorno virtual}
...

\subsection{Generación de \textit{datasets} para \textit{phishing}}

Cuando se quieran generar vectores de características para un número elevado de instancias, se recomienda hacerlo protegiendo la identidad del usuario mediante el uso de un \textit{proxy} de Tor. Para ello:

\begin{enumerate}
	\item Entrar en el directorio \texttt{semisupervised-learning-in-cibersecurity /src/scripts}
	\item Lanzar el \textit{script} para levantar \textit{proxies} mediante el comando \texttt{\$ sudo python3 proxies\_launcher.py}
	\item Introducir por teclado el número de \textit{proxies} deseados y esperar a que se levanten.
	\item Generar el \textit{dataset} ejecutando el \textit{notebook} \texttt{phishing\_dataset\_generator .ipynb} mediante VSCode.
\end{enumerate}

\subsection{Ejecución de experimentos en remoto}

Hay ocasiones en las que los experimentos lanzados requieren una cantidad muy elevada de recursos. En dichos casos, lo mejor es ejecutar los \textit{scripts} en servidores de mayor envergadura. Para ello se seguirán los siguientes pasos:

\begin{enumerate}
	\item Activar la \texttt{vpn} de la UBU\footnote{\url{https://www.ubu.es/servicio-de-informatica-y-comunicaciones/documentacion-de-ayuda/manuales-de-usuario/manuales-vpn}} (se requiere autorización previa).
	\item Acceder al servidor deseado vía \texttt{ssh}. Para ello, ejecutar el comando \texttt{ssh -X -p 22 usuario@ipmáquina} y autenticarse.
	\item Si es la primera ejecución:
		\begin{enumerate}
			\item Descargar el repositorio deseado mediante \texttt{git} o copiar los archivos mediante el comando \texttt{\$ scp -r ubicaciónlocal usuario} \texttt{@ipmáquina:ubicaciónremota}. Si se usa el comando \texttt{\$ scp}, hacerlo desde local.
			\item Crear un entorno virtual (o copiar uno existente mediante \texttt{scp} en caso de falta de permisos).
		\end{enumerate}
	\item Para evitar que el proceso lanzado se muera al cerrar el \texttt{ssh}, abrir una terminal de \texttt{tmux} mediante el comando \texttt{\$ tmux}.
	\item Activar el entorno virtual.
	\item Lanzar el \textit{script} deseado desde \texttt{tmux} mediante el comando \texttt{python3 script.py}.
	\item Desacoplar la terminal pulsando \texttt{Ctrl + b y luego d}.
	\item Comprobar que el \textit{script} se está ejecutando mediante \texttt{ps -fA | grep python}
	\item Consultar los logs mediante el comando \texttt{\$ nano} o \texttt{\$ tail}.
	\item Copiar los ficheros resultantes a local mediante \texttt{\$ scp}.
	\item Si se quiere recuperar la terminal desacoplada, hacerlo mediante \texttt{\$ tmux attach}.
\end{enumerate}

\subsection{\textit{Web}: Despliegue en local (servidor de Flask y base de datos PostgreSQL)}

Para programar y probar la aplicación \textit{web}, se recomienda utilizar el propio servidor de Flask. Para ello, se han de seguir los siguientes pasos:

\begin{enumerate}
	\item Entrar en el directorio \texttt{\$ semisupervised-learning-in-cibersecurity /src/krini\_web}
	\item Activar el entorno virtual \texttt{\$ . env/bin/activate}
	\item Exportar las variables de entorno \texttt{\$ export FLASK\_APP=run.py}
	\item Activar el modo depuración \texttt{\$ export FLASK\_ENV=development}
	\item Lanzar el servidor mediante el comando \texttt{\$ flask run --host=127.0.0.1 --port=5000}. Evidentemente, se pueden configurar las direcciones y puertos que se considere necesario.
\end{enumerate}

\textbf{Nota:} para desarrollo, se ha utilizado una base de datos PostgreSQL en \texttt{localhost}. En Ubuntu se puede configurar siguiendo las instrucciones mostradas en~\cite{postgrelocal}. Es importante contar con una base de datos llamada \texttt{krini}, un usuario \texttt{dev} con privilegios y contraseña \texttt{123}. Las tablas se crean solas (mediante SQLAlchemy) al visitar la aplicación.

\subsubsection{Compilar y modificar los archivos de idiomas}

Cuando se introduzca una cadena nueva en el programa, se debe etiquetar mediante la función \texttt{gettext()}. Posteriormente, se han de seguir los pasos mostrados a continuación~\cite{pybabelmanual}:

\begin{enumerate}
	\item Entrar en el directorio \texttt{\$ semisupervised-learning-in-cibersecurity /src/krini\_web}
	\item Activar el entorno virtual \texttt{\$ . env/bin/activate}
	\item Actualizar el fichero \texttt{.pot \$ pybabel extract -F babel.cfg -o}
	
	\texttt{ messages.pot --input-dirs=. }
	\item La primera vez, generar los ficheros \texttt{.po} y \texttt{.mo} mediante el comando \texttt{\$pybabel init -i messages.pot -d translations -l <idioma>}.
	Las veces sucesivas, simplemente actualizar mediante el comando \texttt{\$pybabel update -i messages.pot -d}.
	\item Realizar los cambios que se desee en el fichero \texttt{.po}.
	\item Compilar las modificaciones \texttt{\$ pybabel compile -d translations}. 
\end{enumerate}

\subsection{\textit{Web}: Despliegue en Docker}

Para garantizar que la aplicación pueda ejecutarse independientemente del sistema anfitrión, se han utilizado contenedores de Docker.

A nivel de usuario se ha automatizado el despliegue mediante \textit{scripts} multiplataforma\footnote{Disponibles en \url{https://github.com/phf1001/semisupervised-learning-in-cibersecurity/tree/main/docker-deploy-kit}} que descargan las imágenes del repositorio de DockerHub\footnote{Disponible en \url{https://hub.docker.com/r/phf1001/krini}} de la autora~\cite{dockerHub}. Los pasos necesarios serán descritos en la correspondiente sección del manual.

A nivel de programador, se ha configurado el archivo \texttt{DockerFile} que genera una imagen de Python en la que se copia la carpeta \texttt{src} del repositorio e instala el archivo \texttt{requirements.txt}. Para levantar los contenedores, se facilita el correspondiente archivo \texttt{docker-compose}, que lanza la \textit{web} y una base de datos PostgreSQL~\cite{dockerFlaskPostgre}. Para hacer la base de datos persistente y evitar que se reinicie cada vez que se levanta la imagen, se ha mapeado un volumen \texttt{data}~\cite{dockerPersist}.

Además, para que los usuarios no tengan la base de datos vacía, se ha creado un \textit{script} de Python que se ejecuta en el contenedor gracias al \texttt{docker-compose} e inserta usuarios, modelos, URLs y reportes. Está copiado en la imagen.

De esta forma, cuando un programador quiera actualizar las imágenes de Docker debe:

\begin{enumerate}
	\item Entrar en el directorio raíz del repositorio \texttt{\$ semisupervised-learning -in-cibersecurity}.
	\item Ejecutar el comando \texttt{\$ docker-compose build --no-cache}.
	\item Ejecutar el comando \texttt{\$ docker-compose -f docker-compose.yml up -d --build}.
	\item Comprobar que ambas imágenes están disponibles mediante \texttt{\$ docker images -a}.
	\item Actualizar la web en DockerHub mediante \texttt{\$ docker tag semisupervised -learning-in-cibersecurity\_web phf1001/krini:web-<número> \&\& docker push phf1001/krini:web-v<número>}
	\item Actualizar la base de datos en DockerHub mediante \texttt{\$ docker tag postgres phf1001/krini:db-v<número> \&\& docker push phf1001 /krini:db-v<número>}
	\item Cambiar las versiones en los \texttt{docker-compose} para los clientes.
\end{enumerate}

Nota: durante el desarrollo, a veces se ha dejado el puerto 5432 expuesto por motivos de comodidad (acceso a la base de datos por terminal). Si Docker avisa de que no puede levantar contenedores ya que el puerto esta ocupado, se recomienda ejecutar \texttt{\$ sudo netstat -p -nlp | grep 5432} para comprobar por quién y, si se está de acuerdo, matar el proceso mediante \texttt{sudo kill <PID>}. Si no se necesitan los puertos, también se puede eliminar el campo \texttt{ports} del \texttt{docker-compose}

Nota: se dispone de un \textit{script} tanto en \texttt{.sh} como en \texttt{.bat} llamado \texttt{docker-clean} que pausa, limpia y elimina contenedores (e imágenes) para liberar recursos.


\subsection{\textit{Web}: Despliegue en Heroku}

El despliegue en Heroku se complica un poco más de lo habitual por la estructura de directorios creada (la aplicación \textit{web} se encuentra varias carpetas alejada de la raíz y hace uso de elementos externos).

Los pasos seguidos para desplegar la aplicación se pueden consultar en~\cite{herokudeploy}. Es destacable la necesidad de crear un archivo \texttt{Procfile} (define los pasos que se ejecutan al iniciar la aplicación~\cite{herokuprocfile}) que se encuentre en la raíz del directorio que se quiere desplegar (en este caso, sólo \texttt{src}, no tiene sentido subir la documentación) junto con el archivo \texttt{requirements.txt} de la \textit{web}. Además, se ha incluído un fichero \texttt{runtime.txt} para indicar la versión de Python deseada.

Nótese que el fichero \texttt{Procfile} almacena el contenido \texttt{\$ web: cd krini\_web \&\& gunicorn run:app --log-file=-} (por la necesidad comentada de cambiar de directorio ya que se encuentra dentro de \texttt{src} para que Heroku encuentre la aplicación). Al igual que en Docker, se ha utilizado un servidor Gunicorn por ser un servidor WSGI\footnote{\textit{Web Server Gateway Interface}: especificación que describe cómo se comunica un servidor \textit{web} con una aplicación \textit{web} y cómo se procesan las solicitudes/peticiones.} compatible con varios \textit{frameworks} (entre ellos, Flask).

Para desplegar únicamente \texttt{src}~\cite{herokusubtree}, el comando clásico se complica un poco. Los pasos son:

\begin{enumerate}
	\item Entrar en el directorio raíz del repositorio \texttt{\$ semisupervised-learning -in-cibersecurity}.
	\item Ejecutar el comando \texttt{\$ git subtree push --prefix src/ heroku main
	}. Es probable que requiera un inicio de sesión.
\end{enumerate}

La base de datos PostgreSQL de la \textit{web} también se ha desplegado en Heroku mediante un \textit{add-on} y es accesible por CLI mediante el comando \texttt{\$
heroku pg:psql <base> --app krini}. En código, se recupera la URI de conexión mediante variables de entorno.

\section{\textit{Web}: Compilación, instalación y ejecución de herramientas auxiliares}

\begin{figure}[h]
	\caption[\textit{Co-forest}: Configuración de un experimento en KEEL]{Configuración de un experimento que utiliza el algoritmo \textit{co-forest} mediante la GUI de KEEL.}
	\centering
	\includegraphics[scale=0.5]{../img/anexos/manual/keel_gui.png}
\end{figure}

\subsection{KEEL}

KEEL es una herramienta que permite experimentar con modelos de \textit{machine learning}. Ha sido creada por distintas universidades españolas y financiada por el Ministerio de Educación y Ciencia~\cite{KEEL}.

Para poder ejecutarla, en primer lugar, se han de descargar los ficheros fuente del repositorio de GitHub~\cite{keelRepo}. Una vez se han descargado, se compilan aprovechando el fichero \texttt{build.xmlz} contenido y la herramienta \texttt{ant}. Mediante el comando \texttt{ant cleanAll} se eliminan barios previos (para evitar conflictos), y mediante el comando \texttt{ant} se compila el código fuente.

Posteriormente se ejecuta la aplicación mediante el comando \texttt{java -jar ./dist/GraphInterKeel.jar} y se utiliza mediante su interfaz gráfica.


\section{Pruebas del sistema}
\label{s:pruebas}

Las pruebas \textit{software} son un proceso sistemático y controlado para evaluar y verificar el correcto funcionamiento de un producto. Están reguladas por la ISO/IEC/IEEE 29119~\cite{iso-pruebas} y son fundamentales ya que permiten detectar errores y defectos antes del despliegue, pudiendo así ahorrar costos, tiempo, y facilitando la satisfacción del cliente.

Existen distintos tipos de pruebas en función de qué se está evaluando. Generalmente se sigue un enfoque de más bajo nivel a más alto nivel, iniciando en las pruebas unitarias y finalizando en las pruebas de aceptación.


\subsection{Pruebas unitarias}
\label{s:pruebas-unitarias}

Las pruebas unitarias se centran en comprobar el correcto funcionamiento de las partes individuales del \textit{software}. Se llevan a cabo a nivel de código y están diseñadas para detectar errores y defectos en unidades de menor tamaño (por ejemplo funciones o clases).

Debido a que los algoritmos de ML cuentan con pruebas independientes (comparaciones con otras implementaciones) y la \textit{web} cuenta con las pruebas descritas en la sección~\ref{s:pruebas-aceptación}, se han realizado pruebas unitarias para la clase de utilidades \texttt{phishing\_utils}.

Además, las pruebas unitarias se han automatizado mediante Travis CI, de forma que cada vez que se hace un \textit{push} a las ramas principales o de desarrollo se dispara una \textit{build} que las ejecuta automáticamente como se muestra en la imagen~\ref{d:cp-travis}.

\begin{figure}[h]
	\caption[TravisCI: ejecución automática de pruebas unitarias]{Ejecución automática de las pruebas unitarias mediante TravisCI.}
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/travis-tests}
	\label{d:cp-travis}
\end{figure}


\subsection{Pruebas de aceptación}
\label{s:pruebas-aceptación}

Las pruebas de aceptación se realizan para verificar si el \textit{software} está listo para su implementación y si cumple con los criterios de aceptación del cliente. En este proyecto se han querido evaluar algunos de los casos más <<extraños>> con el fin de comprobar su correcto funcionamiento. Estos se han organizado en tres \textit{test suites} divididas por categorías.

Todos los casos de prueba mostrados en las tablas han sido automatizados utilizando Selenium (como se puede observar en la imagen~\ref{cp:selenium}). Los \textit{test} se facilitan en el repositorio de la aplicación, además de los datos necesarios para ejecutarlos.

\begin{figure}[h]
	\caption[Selenium: ejecución automática de pruebas de aceptación]{Ejecución automática de las pruebas de aceptación y seguridad con la herramienta Selenium.}
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/selenium-tests}
	\label{cp:selenium}
\end{figure}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-1}
	\caption{CP-1 Acceso a página restringida.}
	\label{cp:acc-restringido}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-2}
	\caption{CP-2 Intento de registro con cuenta accedida.}
	\label{cp:registro}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-3}
	\caption{CP-3 Acceso a recursos estáticos.}
	\label{cp:acc-html}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-4}
	\caption{CP-4 Acceso a rutas excepcionales.}
	\label{cp:wrong-stream}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-5}
	\caption{CP-5 Cambio de idioma.}
	\label{cp:language}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-6}
	\caption{CP-6 Pantallas responsivas.}
	\label{cp:hamburguer-menu}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-7}
	\caption{CP-7 Funcionamiento de las \textit{check-boxes}.}
	\label{cp:checkboxes}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-8}
	\caption{CP-8 Análisis enlace incompleto.}
	\label{cp:url-incompleta}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-9}
	\caption{CP-9 Análisis enlace erróneo.}
	\label{cp:wrong-url}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-10}
	\caption{CP-10 Actualización del perfil con las denuncias de URLs.}
	\label{cp:report-url}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-11}
	\caption{CP-11 \texttt{csv} con formato incorrecto.}
	\label{cp:wrong-csv}
\end{table}

\begin{table}[p]
	\centering
	\includegraphics[width=\textwidth]{../img/anexos/cp/CP-12}
	\caption{CP-12 \texttt{csv} con conjunto de \textit{test} anómalo.}
	\label{cp:strange-csv}
\end{table}